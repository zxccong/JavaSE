1.多线程(单例设计模式)(掌握)
  * 单例设计模式：保证类在内存中只有一个对象。

  * 如何保证类在内存中只有一个对象呢？
  	* (1)控制类的创建，不让其他类来创建本类的对象。private
  	* (2)在本类中定义一个本类的对象。Singleton s;
  	* (3)提供公共的访问方式。  public static Singleton getInstance(){return s}
  * 单例写法两种：
  	* (1)饿汉式 开发用这种方式。
  	*
  			//饿汉式
  			class Singleton {
  				//1,私有构造函数
  				private Singleton(){}
  				//2,创建本类对象
  				private static Singleton s = new Singleton();
  				//3,对外提供公共的访问方法
  				public static Singleton getInstance() {
  					return s;
  				}

  				public static void print() {
  					System.out.println("11111111111");
  				}
  			}
  	* (2)懒汉式 面试写这种方式。多线程的问题？
  	*
  			//懒汉式,单例的延迟加载模式
  			class Singleton {
  				//1,私有构造函数
  				private Singleton(){}
  				//2,声明一个本类的引用
  				private static Singleton s;
  				//3,对外提供公共的访问方法
  				public static Singleton getInstance() {
  					if(s == null)
  						//线程1,线程2
  						s = new Singleton();
  					return s;
  				}

  				public static void print() {
  					System.out.println("11111111111");
  				}
  			}
  	* (3)第三种格式
  	*
  			class Singleton {
  				private Singleton() {}

  				public static final Singleton s = new Singleton();//final是最终的意思,被final修饰的变量不可以被更改
  			}

  			Demo1_Sinleton.java

2.多线程(Runtime类)
  * Runtime类是一个单例类
  	*
  			Runtime r = Runtime.getRuntime();
  			//r.exec("shutdown -s -t 300");		//300秒后关机
  			r.exec("shutdown -a");				//取消关机

  			Demo2_Runtime

3.多线程(Timer)(掌握)
  * Timer类:计时器

  			public class Demo5_Timer {
  				/**
  				 * @param args
  				 * 计时器
  				 * @throws InterruptedException
  				 */
  				public static void main(String[] args) throws InterruptedException {
  					Timer t = new Timer();
  					t.schedule(new MyTimerTask(), new Date(114,9,15,10,54,20),3000);

  					while(true) {
  						System.out.println(new Date());
  						Thread.sleep(1000);
  					}
  				}
  			}
  			class MyTimerTask extends TimerTask {
  				@Override
  				public void run() {
  					System.out.println("起床背英语单词");
  				}

  			}

  			Demo3_Time.java

4.多线程(两个线程间的通信)(掌握)
  * 1.什么时候需要通信
  	* 多个线程并发执行时, 在默认情况下CPU是随机切换线程的
  	* 如果我们希望他们有规律的执行, 就可以使用通信, 例如每个线程执行一次打印
  * 2.怎么通信
  	* 如果希望线程等待, 就调用wait()
  	* 如果希望唤醒等待的线程, 就调用notify();（随机）
  	* 这两个方法必须在同步代码中执行, 并且使用同步锁对象来调用
5.多线程(三个或三个以上间的线程通信)
  * 多个线程通信的问题
  	* notify()方法是随机唤醒一个线程
  	* notifyAll()方法是唤醒所有线程
  	* JDK5之前无法唤醒指定的一个线程
  	* 如果多个线程之间通信, 需要使用notifyAll()通知所有线程, 用while来反复判断条件
  	（问题！！！）
  	1.同步代码块中，用哪个对象锁，就用哪个对象调用wait()方法
  	2.为什么wait方法和notify方法定义在Object这个类中
  	    因为锁对象是任意对象，Object是所以wait方法和notity方法需要定义在Object这个类中
    3.sleep方法和wait方法的区别
       1.sleep必须传入参数，到达时间自动醒来
         wait可以传入参数，传入参数，等参数时间结束后再等待
       2.sleep方法不释放锁
         wait方法在同步代码块中，释放锁

6.多线程(JDK1.5的新特性互斥锁)(掌握)
  * 1.同步
  	* (！！！)使用ReentrantLock类的lock()和unlock()方法进行同步
  * 2.通信
  	* 使用ReentrantLock类的newCondition()方法可以获取Condition对象
  	* 需要等待的时候使用(！！！)Condition的await()方法, 唤醒的时候用signal()方法
  	* 不同的线程使用不同的Condition, 这样就能区分唤醒的时候找哪个线程了
7.多线程(线程组的概述和使用)(了解)
  * A:线程组概述
  	* Java中使用ThreadGroup（！！！默认主线程组）来表示线程组，它可以对一批线程进行分类管理，Java允许程序直接对线程组进行控制。
  	* 默认情况下，所有的线程都属于主线程组。
  		* public final ThreadGroup getThreadGroup()//通过线程对象获取他所属于的组
  		* public final String getName()//通过线程组对象获取他组的名字
  	* 我们也可以给线程设置分组
  		* 1,ThreadGroup(String name) 创建线程组对象并给其赋值名字
  		* 2,创建线程对象
  		* 3,Thread(ThreadGroup?group, Runnable?target, String?name)（！！！构造方法定义线程组）
  		* 4,设置整组的优先级或者守护线程
  	* B:案例演示
  		* 线程组的使用,默认是主线程组
  *
  		MyRunnable mr = new MyRunnable();
  		Thread t1 = new Thread(mr, "张三");
  		Thread t2 = new Thread(mr, "李四");
  		//获取线程组
  		// 线程类里面的方法：public final ThreadGroup getThreadGroup()
  		ThreadGroup tg1 = t1.getThreadGroup();
  		ThreadGroup tg2 = t2.getThreadGroup();
  		// 线程组里面的方法：public final String getName()
  		String name1 = tg1.getName();
  		String name2 = tg2.getName();
  		System.out.println(name1);
  		System.out.println(name2);
  		// 通过结果我们知道了：线程默认情况下属于main线程组
  		// 通过下面的测试，你应该能够看到，默任情况下，所有的线程都属于同一个组
  		System.out.println(Thread.currentThread().getThreadGroup().getName());

  	* 自己设定线程组
  *
  		// ThreadGroup(String name)
  		ThreadGroup tg = new ThreadGroup("这是一个新的组");

  		MyRunnable mr = new MyRunnable();
  		// Thread(ThreadGroup group, Runnable target, String name)
  		Thread t1 = new Thread(tg, mr, "张三");
  		Thread t2 = new Thread(tg, mr, "李四");

  		System.out.println(t1.getThreadGroup().getName());
  		System.out.println(t2.getThreadGroup().getName());

  		//通过组名称设置后台线程，表示该组的线程都是后台线程
  		tg.setDaemon(true);（！！！整个组设置为守护线程）
8.多线程(线程的五种状态)(掌握)
  * 看图说话
  * 新建(new),就绪（start）,运行(获得执行资格),阻塞（sleep(),wait()）,死亡（运行结束或变成垃圾）
9.多线程(线程池的概述和使用)(了解)
  * A:线程池概述
  	* 程序启动一个新线程成本是比较高的，因为它涉及到要与操作系统进行交互。而使用线程池可以很好的提高性能，尤其是当程序中要创建大量生存期很短的线程时，更应该考虑使用线程池。线程池里的每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，等待下一个对象来使用。在JDK5之前，我们必须手动实现自己的线程池，从JDK5开始，Java内置支持线程池
  * B:内置线程池的使用概述
  	* JDK5新增了一个Executors工厂类来产生线程池，有如下几个方法
  		* public static ExecutorService newFixedThreadPool(int nThreads)(！！！固定线程的线程数量)
  		* public static ExecutorService newSingleThreadExecutor()（！！！单个线程的线程）
  		* 这些方法的返回值是ExecutorService对象，该对象表示一个线程池，可以执行Runnable对象或者Callable对象代表的线程。它提供了如下方法
  		* Future<?> submit(Runnable task)
  		* <T> Future<T> submit(Callable<T> task)
  	* 使用步骤：
  		* 创建线程池对象
  		* 创建Runnable实例
  		* 提交Runnable实例
  		* 关闭线程池
  	* C:案例演示
  		* 提交的是Runnable
  *
  		// public static ExecutorService newFixedThreadPool(int nThreads)
  		ExecutorService pool = Executors.newFixedThreadPool(2);

  		// 可以执行Runnable对象或者Callable对象代表的线程
  		pool.submit(new MyRunnable());
  		pool.submit(new MyRunnable());

  		//结束线程池
  		pool.shutdown();
10.多线程(多线程程序实现的方式3)(了解)
   * 提交的是Callable

   *
   		// 创建线程池对象
   		ExecutorService pool = Executors.newFixedThreadPool(2);

   		// 可以执行Runnable对象或者Callable对象代表的线程
   		Future<Integer> f1 = pool.submit(new MyCallable(100));
   		Future<Integer> f2 = pool.submit(new MyCallable(200));

   		// V get()
   		Integer i1 = f1.get();
   		Integer i2 = f2.get();

   		System.out.println(i1);
   		System.out.println(i2);

   		// 结束
   		pool.shutdown();

   		public class MyCallable implements Callable<Integer> {

   			private int number;

   			public MyCallable(int number) {
   				this.number = number;
   			}

   			@Override
   			public Integer call() throws Exception {
   				int sum = 0;
   				for (int x = 1; x <= number; x++) {
   					sum += x;
   				}
   				return sum;
   			}

   		}
   * 多线程程序实现的方式3的好处和弊端
   	* 好处：
   		* 可以有返回值
   		* 可以抛出异常

   	* 弊端：
   		* 代码比较复杂，所以一般不用




