1.多线程(单例设计模式)(掌握)
  * 单例设计模式：保证类在内存中只有一个对象。

  * 如何保证类在内存中只有一个对象呢？
  	* (1)控制类的创建，不让其他类来创建本类的对象。private
  	* (2)在本类中定义一个本类的对象。Singleton s;
  	* (3)提供公共的访问方式。  public static Singleton getInstance(){return s}
  * 单例写法两种：
  	* (1)饿汉式 开发用这种方式。
  	*
  			//饿汉式
  			class Singleton {
  				//1,私有构造函数
  				private Singleton(){}
  				//2,创建本类对象
  				private static Singleton s = new Singleton();
  				//3,对外提供公共的访问方法
  				public static Singleton getInstance() {
  					return s;
  				}

  				public static void print() {
  					System.out.println("11111111111");
  				}
  			}
  	* (2)懒汉式 面试写这种方式。多线程的问题？
  	*
  			//懒汉式,单例的延迟加载模式
  			class Singleton {
  				//1,私有构造函数
  				private Singleton(){}
  				//2,声明一个本类的引用
  				private static Singleton s;
  				//3,对外提供公共的访问方法
  				public static Singleton getInstance() {
  					if(s == null)
  						//线程1,线程2
  						s = new Singleton();
  					return s;
  				}

  				public static void print() {
  					System.out.println("11111111111");
  				}
  			}
  	* (3)第三种格式
  	*
  			class Singleton {
  				private Singleton() {}

  				public static final Singleton s = new Singleton();//final是最终的意思,被final修饰的变量不可以被更改
  			}

  			Demo1_Sinleton.java

2.多线程(Runtime类)
  * Runtime类是一个单例类
  	*
  			Runtime r = Runtime.getRuntime();
  			//r.exec("shutdown -s -t 300");		//300秒后关机
  			r.exec("shutdown -a");				//取消关机

  			Demo2_Runtime

3.多线程(Timer)(掌握)
  * Timer类:计时器

  			public class Demo5_Timer {
  				/**
  				 * @param args
  				 * 计时器
  				 * @throws InterruptedException
  				 */
  				public static void main(String[] args) throws InterruptedException {
  					Timer t = new Timer();
  					t.schedule(new MyTimerTask(), new Date(114,9,15,10,54,20),3000);

  					while(true) {
  						System.out.println(new Date());
  						Thread.sleep(1000);
  					}
  				}
  			}
  			class MyTimerTask extends TimerTask {
  				@Override
  				public void run() {
  					System.out.println("起床背英语单词");
  				}

  			}

  			Demo3_Time.java

4.多线程(两个线程间的通信)(掌握)
  * 1.什么时候需要通信
  	* 多个线程并发执行时, 在默认情况下CPU是随机切换线程的
  	* 如果我们希望他们有规律的执行, 就可以使用通信, 例如每个线程执行一次打印
  * 2.怎么通信
  	* 如果希望线程等待, 就调用wait()
  	* 如果希望唤醒等待的线程, 就调用notify();（随机）
  	* 这两个方法必须在同步代码中执行, 并且使用同步锁对象来调用
5.多线程(三个或三个以上间的线程通信)
  * 多个线程通信的问题
  	* notify()方法是随机唤醒一个线程
  	* notifyAll()方法是唤醒所有线程
  	* JDK5之前无法唤醒指定的一个线程
  	* 如果多个线程之间通信, 需要使用notifyAll()通知所有线程, 用while来反复判断条件
  	（问题！！！）
  	1.同步代码块中，用哪个对象锁，就用哪个对象调用wait()方法
  	2.为什么wait方法和notify方法定义在Object这个类中
  	    因为锁对象是任意对象，Object是所以wait方法和notity方法需要定义在Object这个类中
    3.sleep方法和wait方法的区别
       1.sleep必须传入参数，到达时间自动醒来
         wait可以传入参数，传入参数，等参数时间结束后再等待
       2.sleep方法不释放锁
         wait方法在同步代码块中，释放锁

6.多线程(JDK1.5的新特性互斥锁)(掌握)
  * 1.同步
  	* (！！！)使用ReentrantLock类的lock()和unlock()方法进行同步
  * 2.通信
  	* 使用ReentrantLock类的newCondition()方法可以获取Condition对象
  	* 需要等待的时候使用Condition的await()方法, 唤醒的时候用signal()方法
  	* 不同的线程使用不同的Condition, 这样就能区分唤醒的时候找哪个线程了
7.

